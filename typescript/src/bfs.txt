const bfs: (start: Point, end: Point, maze: Maze) => Point[] | null = (start, end, maze) => {
  const queue: Point[] = [start]
  const cameFrom: Map<string, Point | null> = new Map()
  cameFrom.set(`${start.x},${start.y}`, null)

  while (queue.length > 0) {
    const current = queue.shift()!

    if (current.x === end.x && current.y === end.y) {
      let path: Point[] = []
      let at: Point | null = current
      while (at !== null) {
        path.push(at)
        at = cameFrom.get(`${at.x},${at.y}`) ?? null
      }
      return path.reverse()
    }

    // Nykyisen pisteen naapurit
    const directions: Point[] = [
      { x: current.x + 1, y: current.y },
      { x: current.x - 1, y: current.y },
      { x: current.x, y: current.y + 1 },
      { x: current.x, y: current.y - 1 },
      { x: current.x + 1, y: current.y + 1 },
      { x: current.x + 1, y: current.y - 1 },
      { x: current.x - 1, y: current.y - 1 },
      { x: current.x - 1, y: current.y + 1 },
    ]

    // Naapurien tarkistus
    for (const dir of directions) {
      if (canMove(current, dir, maze) && !cameFrom.has(`${dir.x},${dir.y}`)) {
        queue.push(dir)
        cameFrom.set(`${dir.x},${dir.y}`, current)
      }
    }
  }

  return null // Ei reittiä löytynyt
}








const bfs = (start: Point, end: Point, maze: number[][]): Point[] | null => {
  let queue: PointWithDirection[] = [{ ...start, direction: '', turns: 0, parent: null }]
  let visited = new Set<string>()
  let turnsMap = new Map<string, number>()
  let bestPath: Point[] = []
  let bestPathTurns = Infinity

  visited.add(`${start.x},${start.y}`)
  turnsMap.set(`${start.x},${start.y}`, 0)

  while (queue.length > 0) {
    const current = queue.shift()!
    const currentKey = `${current.x},${current.y}`

    if (current.x === end.x && current.y === end.y) {
      let path: Point[] = []
      let pathTurns = current.turns
      let at = current

      while (at !== null) {
        path.unshift({ x: at.x, y: at.y })
        at = at.parent
      }

      if (pathTurns < bestPathTurns) {
        bestPath = path
        bestPathTurns = pathTurns
      }

      continue // Jatka jonon läpikäyntiä, jos on muita reittejä maaliin
    }

    const directions = [
      { dx: 1, dy: 0, direction: 'right' },
      { dx: -1, dy: 0, direction: 'left' },
      { dx: 0, dy: 1, direction: 'down' },
      { dx: 0, dy: -1, direction: 'up' },
      // Viistosuunnat
      { dx: 1, dy: 1, direction: 'down-right' },
      { dx: 1, dy: -1, direction: 'up-right' },
      { dx: -1, dy: -1, direction: 'up-left' },
      { dx: -1, dy: 1, direction: 'down-left' },
    ]

    for (const { dx, dy, direction } of directions) {
      const nextPoint = { x: current.x + dx, y: current.y + dy }
      const nextKey = `${nextPoint.x},${nextPoint.y}`
      const newTurns = current.direction !== direction ? current.turns + 1 : current.turns

      // Tarkistetaan, voiko liikkua ja onko uusi reitti tehokkaampi tai yhtä tehokas kuin aiemmin tallennettu
      if (canMove(current, nextPoint, maze)) {
        const existingTurns = turnsMap.get(nextKey)
        if (existingTurns === undefined || newTurns <= existingTurns) {
          // Jos uusi reitti on tehokkaampi tai ensimmäinen kerta pisteeseen, sallitaan liike ja päivitetään tiedot
          if (existingTurns === undefined) {
            visited.add(nextKey) // Merkitään piste käydyksi, jos se on ensimmäinen kerta
          }
          turnsMap.set(nextKey, newTurns) // Päivitetään tai asetetaan käännösten määrä
          queue.push({
            ...nextPoint,
            direction,
            turns: newTurns,
            parent: current,
          })
        }
      }
    }
  }

  return bestPath.length > 0 ? bestPath : null
}









const bfs = (start: Point, end: Point, maze: number[][]): Point[] | null => {
  let queue: PointWithDirection[] = [{ ...start, direction: '', turns: 0, steps: 0, parent: null }]
  let visited = new Map<string, number>() // Avaimena pisteen koordinaatit, arvona pienin löydettyjen käännösten määrä
  let bestPath: Point[] = []
  let bestScore = Infinity

  visited.set(`${start.x},${start.y}`, 0)

  while (queue.length > 0) {
    const current = queue.shift()!
    const currentKey = `${current.x},${current.y}`

    if (current.x === end.x && current.y === end.y) {
      let score = current.turns + current.steps
      if (score < bestScore) {
        bestScore = score
        bestPath = []
        let at = current
        while (at) {
          bestPath.unshift({ x: at.x, y: at.y })
          at = at.parent
        }
      }
      continue
    }

    const directions = [
      { dx: 1, dy: 0, direction: 'right' },
      { dx: -1, dy: 0, direction: 'left' },
      { dx: 0, dy: 1, direction: 'down' },
      { dx: 0, dy: -1, direction: 'up' },
      { dx: 1, dy: 1, direction: 'down-right' },
      { dx: 1, dy: -1, direction: 'up-right' },
      { dx: -1, dy: -1, direction: 'up-left' },
      { dx: -1, dy: 1, direction: 'down-left' },
    ]

    for (const { dx, dy, direction } of directions) {
      const nextPoint = { x: current.x + dx, y: current.y + dy }
      const nextKey = `${nextPoint.x},${nextPoint.y}`
      const newTurns = current.direction !== direction ? current.turns + 1 : current.turns
      const newSteps = current.steps + 1
      const newScore = newTurns + newSteps

      if (canMove(current, nextPoint, maze)) {
        const existingScore = visited.get(nextKey)
        if (existingScore === undefined || newScore < existingScore) {
          visited.set(nextKey, newScore)
          queue.push({
            ...nextPoint,
            direction,
            turns: newTurns,
            steps: newSteps,
            parent: current,
          })
        }
      }
    }
  }

  return bestPath.length > 0 ? bestPath : null
}